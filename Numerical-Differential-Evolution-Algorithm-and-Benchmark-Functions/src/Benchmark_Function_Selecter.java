import java.util.List;

/**
 * This class is used to select the correct benchmark function according to the users choice.
 * There are 5 functions that are possible to be chosen and each of those 5 functions perform 
 * are optimized using the Differential Evolution Algorithm. 
 * @author Devan Shah 100428864, Parth Patel 100392782, Ravikumar Patel 100423830
 *
 */
public class Benchmark_Function_Selecter {
	
	/**
	 * This method is responsible for selecting the correct benchmark function and generating the initial 
	 * population for the selecting function, using the provided bounds of the function. Once the initial
	 * population has been generated by the Generated_Initial_Population method the population is passed 
	 * to the Differential_Evolution_Algorithm, where the Algorithm is applied to try and minimize the 
	 * selected function. 
	 * 
	 * @param benchmarkSelection is the integer value that the user inputs, which is used to select the function
	 * @param runs is an integer value that can be either 1 or 50, which is used to determine if the program will 
	 * 		       will generated the mean and standard deviation of 50 runs or construct a graph of 30000 generations 
	 * @param optionSelection is an integer value that decides if a graph or mean and standard deviation is generated
	 *                        for a given function
	 */
	public static void Benchmark_Function_Selection(int benchmarkSelection, int runs, int optionSelection) {
		// Variable Definition 
		List<List<Double>> initialPopulation; // 2D array list that stores the initialPopulation that is 60 by 30
		
		// Switch case used to select the functions according to the users input these. Has a complexity of O(n).
		switch (benchmarkSelection) {
			
			case 1:
				// Function 1 - 1st De Jong 
				initialPopulation = Initial_Population_Generator.Generate_Initial_Population(-5.12, 5.12);
				Numerical_Differential_Evolution_Algorithm.Differential_Evolution_Algorithm(initialPopulation, 1, runs, optionSelection, -5.12, 5.12);
				break;
			case 2:
				// Function 2 - Axis Parallel Hyper-Ellipsoid
				initialPopulation = Initial_Population_Generator.Generate_Initial_Population(-5.12, 5.12);
				Numerical_Differential_Evolution_Algorithm.Differential_Evolution_Algorithm(initialPopulation, 2, runs, optionSelection, -5.12, 5.12);
				break;
			case 3:
				// Function 3 - Schwefel's Problem 1.2
				initialPopulation = Initial_Population_Generator.Generate_Initial_Population(-65, 65);
				Numerical_Differential_Evolution_Algorithm.Differential_Evolution_Algorithm(initialPopulation, 3, runs, optionSelection, -65, 65);
				break;
			case 4:
				// Function 4 - Rosenbrock's Valley
				initialPopulation = Initial_Population_Generator.Generate_Initial_Population(-2, 2);
				Numerical_Differential_Evolution_Algorithm.Differential_Evolution_Algorithm(initialPopulation, 4, runs, optionSelection, -2, 2);
				break;
			case 5:
				// Function 5 - Rastrigin's Function
				initialPopulation = Initial_Population_Generator.Generate_Initial_Population(-5.12, 5.12);
				Numerical_Differential_Evolution_Algorithm.Differential_Evolution_Algorithm(initialPopulation, 5, runs, optionSelection, -5.12, 5.12);
				break;
		}
	}
}
